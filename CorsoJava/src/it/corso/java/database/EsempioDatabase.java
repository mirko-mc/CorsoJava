package it.corso.java.database;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.mysql.cj.jdbc.MysqlDataSource;

public class EsempioDatabase {
	/* interfaccia per la connessione */
	private Connection con;
	
	public static void main(String[] args) {
		EsempioDatabase d = new EsempioDatabase();
		
		try {
			/* verifica se la connessione è chiusa */
			System.out.println("|-------------------------------|");
			System.out.println("| Connsessione chiusa? -> " + d.getConnection().isClosed() + " |");
			System.out.println("|-------------------------------|");
//			d.esInsert("Sara", "Bartoli", "sara@bartoli.it", "9999999");
			d.esSelect1();
			d.esSelect3("Martini");
//			d.esUpdate();
//			d.esDelete();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private void esInsert(String nome,String cognome,String email,String telefono) throws SQLException {
		System.out.println("++++++++++ ESEMPIO INSERT ++++++++++");
		String sql = "INSERT INTO clienti(nome, cognome, email, telefono) "
//				   + "VALUES('" + nome + "', '" + cognome + "', '" + email + "', '" + telefono + "')";
				   + "VALUES(?, ?, ?, ?)";
		/* scegliere preparedstatement con autogenerated keys  dato che la chiave primaria verrà incrementata automaticamente.
		 * abbiamo abilitato il return della chiave generata così da poterla stampare */
		PreparedStatement ps = getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		/* componiamo l'sql in questo modo per prevenire attacchi sql injector in quanto il codice non effettua incjecting diretto
		 * ogni punto interrogativo è un parametro da passare fornendo indice e dato */
		ps.setString(1, nome);
		ps.setString(2, cognome);
		ps.setString(3, email);
		ps.setString(4, telefono);
		
		ps.executeUpdate();
		ResultSet rs = ps.getGeneratedKeys();
		/* il next senza iterazione ci porterà direttamente all'ultimo elemento in tabella, quello appena aggiunto */
		rs.next();
		System.out.println("l'ID del nuovo elemento aggiunto è -> " + rs.getInt(1));
		System.out.println("|||||||||| FINE ESEMPIO ||||||||||");
	}

	public void esSelect1() throws SQLException {
		System.out.println("++++++++++ ESEMPIO SELECT 1 ++++++++++");
		/* prepariamo la query da passare a mysql tramite l'oggetto preparedstatement */
		String sql = "SELECT id, nome, cognome, email, telefono FROM clienti";
		sql = "SELECT id, nome, cognome, email, telefono FROM clienti WHERE cognome LIKE '%Pre%'";
		PreparedStatement ps = getConnection().prepareStatement(sql);
		/* eseguire la query per ottenere un oggetto resultset con i risultati della query */
		ResultSet rs = ps.executeQuery();
		/* iteriamo i risultati per stamparli */
		while (rs.next()) {
			/* per richiamare gli elementi dal result set dobbiamo specificare il tipo e numero colonna corrispondente (parte da 1) */
			System.out.println("id -> " + rs.getInt(1));
			System.out.println("nome -> " + rs.getString(2));
			System.out.println("cognome -> " + rs.getString(3));
			System.out.println("email -> " + rs.getString(4));
			System.out.println("telefono -> " + rs.getString(5));
			System.out.println("--------------------");
		}
		System.out.println("|||||||||| FINE ESEMPIO ||||||||||");		
	}

	private void esSelect3(String cognome) throws SQLException {
		System.out.println("++++++++++ ESEMPIO SELECT 3 ++++++++++");
		/* prepariamo la query da passare a mysql tramite l'oggetto preparedstatement */
		String sql = "SELECT id, nome, cognome, email, telefono FROM clienti WHERE cognome = ?";
		PreparedStatement ps = getConnection().prepareStatement(sql);
		ps.setString(1, cognome); /* indice 1 perchè cognome è 1 */
		/* eseguire la query per ottenere un oggetto resultset con i risultati della query */
		ResultSet rs = ps.executeQuery();
		/* iteriamo i risultati per stamparli */
		while (rs.next()) {
			/* per richiamare gli elementi dal result set dobbiamo specificare il tipo e numero colonna corrispondente (parte da 1) */
			System.out.println("id -> " + rs.getInt(1));
			System.out.println("nome -> " + rs.getString(2));
			System.out.println("cognome -> " + rs.getString(3));
			System.out.println("email -> " + rs.getString(4));
			System.out.println("telefono -> " + rs.getString(5));
			System.out.println("--------------------");
		}
		System.out.println("|||||||||| FINE ESEMPIO SELECT 3 ||||||||||");		
	}

	private void esUpdate() throws SQLException {
		System.out.println("++++++++++ ESEMPIO UPDATE ++++++++++");
		String sql = "UPDATE clienti SET telefono = '1234567' WHERE id = 5";
		PreparedStatement ps = getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		ps.executeUpdate();
		System.out.println("|||||||||| FINE ESEMPIO ||||||||||");
	}

	private void esDelete() throws SQLException {
		System.out.println("++++++++++ ESEMPIO DELETE ++++++++++");
		String sql = "DELETE FROM clienti WHERE id = 6";
		PreparedStatement ps = getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		ps.executeUpdate();
		System.out.println("|||||||||| FINE ESEMPIO ||||||||||");
	}

	private Connection getConnection() throws SQLException {
		if (con == null) {
			MysqlDataSource dataSource = new MysqlDataSource();
			/* compila il datasource con i dati necessari per la connessione */
			dataSource.setServerName("127.0.0.1");
			dataSource.setPortNumber(3306);
//			dataSource.setUser("root");
//			dataSource.setPassword("{06[novembre]18}");
			dataSource.setUser("CorsoJava");
			dataSource.setPassword("Paolo_Preite");
			dataSource.setDatabaseName("corso_java");
			dataSource.setServerTimezone("Europe/Rome");
			
			con = dataSource.getConnection();
		}
		return con;
	}

	/* attacco sql injection è attacco hacker molto particolare e frequente che può causare notevoli danni all'intera applicazione,
	 * compresa la cancellazione totale di tutti i dati.
	 * sql injection = all'interno della query eseguita sono presenti istruzioni che effettua operazioni malevoli come drop database,
	 * cancellazione tabelle o righe, recupero info database
	 * quindi bisogna stare attenti a progettare la classe business, quella che effettua poi l'interrogazione al database
	 * per prevenire attacchi di questo tipo
	 * con preparedstatement si può prevenire questi attacchi
	 * */
}